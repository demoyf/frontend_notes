##### 问题
```
0.1 + 0.2 !== 0.3;

// 输出结果
true
```
**神奇！**

##### Js浮点数的存储
在计算机中，所有数据都是使用二进制保存的，数字也是如此。
Js中只有一种数字类型表示整数和浮点数（Number），它是遵循
>[IEEE754标准](https://baike.baidu.com/item/IEEE%20754) 来自百度百科的解答。

可惜看不懂。

##### 0.1在js中是怎么被存储的？
根据IEEE754标准，小数的表示法是通过 **乘二取整**。
什么是乘二取整呢，实际上就是把起始值(x)乘2，得到y=2*x,
取y的整数位作为当前位置的二进制表示，之后x=y。不断循环这个过程，得到的就是浮点数的二进制。

js是64位的浮点数。

>**注意点：取了整数位之后，整数位需要被去掉。比如下方的1.6取了1就变成了0.6 * 2 = 1.2  1.2再被取1变成了0.2 * 2**

比如0.1
```
    0.1   整数位
×     2
---------------
    0.2     0 
×     2
---------------
    0.4     0   * ↓
×     2
---------------
    0.8     0 
×     2
---------------
    1.6     1 
×     2
---------------
    1.2     1
×     2
---------------
    0.4     0   * ↑
             (0011循环)

因为0.4之后又是一个循环的过程，所以直接就是0.000110011...（0011不断循环）

上面的数据在存储的时候不会直接存储是0.000110011...（0011不断循环） 而是 2^-3(第一个非0数之前的位数) * 0.11001100

而这个2^-3就称为最高位。
```

不过这个获取浮点数二进制表示的过程，不可能是没有终止的，因为无限循环。限制是64位，不过由于还有前12位需要存储符号（占了一个），还有最高位（占了2-12），其余的才是浮点数二进制的存储空间。

```
// 下图采用大端表示，高位在左，低位在右。

符号位 最高位         尾数位
+---+----------+---------------------+
| 1 |   2~12   |         13~64       |
+---+----------+---------------------+

```

那么浮点数的二进制位就是最多容许52位，而后面的数，就通过53号位，1就进一，0就舍去。

讲到这里，浮点数的精度丢失问题就很明显了，就是因为这个进一舍0的过程，导致的浮点数精度丢失。


##### 回到题目
0.1 的二进制是
```
0.00011001100110011001100110011001100110011001100110011010
```

0.2的二进制是
```
0.0011001100110011001100110011001100110011001100110011010
```

相加结果
```
0.00011001100110011001100110011001100110011001100110011010 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111
```

二进制转化的结果
```
0.30000000000000004
```

综上：0.10 +0.2 !== 0.3


>参考文章  

[0.1+0.2!==3?](https://juejin.im/post/5bd2f10a51882555e072d0c4)

[揭秘0.1+0.2!==3](https://www.barretlee.com/blog/2016/09/28/ieee754-operation-in-js/)